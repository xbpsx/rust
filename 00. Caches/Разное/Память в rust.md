Когда мы говорим о памяти в Rust (как и в других системных языках вроде C++), речь идет об **оперативной памяти (ОЗУ)** вашего процесса. ОС выделяет вашей программе определенный объем виртуальной памяти, который Rust делит на две ключевые области: **Стек (Stack)** и **Куча (Heap)**.

### 1. Стек (Stack) — «Быстрая полка»

Здесь хранятся данные, размер которых точно известен в момент написания кода (компиляции). 

- **Что там лежит:** Сама переменная `guess`. Но в ней находится не текст, а «метаданные»: адрес в куче, текущая длина и вместимость.
- **Особенности:** Это очень быстрая память. Как только функция завершается, данные со стека мгновенно «сбрасываются» (как стопка тарелок).


### 2. Куча (Heap) — «Большой склад»

Здесь хранятся данные, размер которых может меняться во время работы программы. 

- **Что там лежит:** Весь текст, который вы вводите в терминале (например, слово `"hello"`). Поскольку программа заранее не знает, сколько букв вы напишете (одну или миллион), она запрашивает место в «куче».
- **Особенности:** Место в куче нужно «искать» (аллокация), что чуть медленнее стека.

### 3. Как это работает вместе в вашем коде?

Когда вы вызываете `io::stdin().read_line(&mut guess)`:

1. **На Стеке** лежит переменная `guess` (указатель).
2. **В Куче** выделяется пустое место под будущую строку.
3. Вы передаете **ссылку** на `guess` (адрес на стеке).
4. Метод `read_line` идет по этому адресу, видит, где в куче зарезервировано место, и записывает туда вводимые вами символы.

#### А что насчет Свапа (Swap)?

Rust не управляет файлом подкачки (свапом) напрямую. Это делает операционная система. Если вашей программе не хватает физической ОЗУ, ОС сама «скинет» неиспользуемые части вашей **Кучи** на диск в свап. Для программы в Rust это выглядит прозрачно — она просто видит «виртуальную память»

### **Итог:**

- **Метаданные (ссылки, указатели):** на Стеке (быстро, локально).
- **Текст (введенные данные):** в Куче (гибко, динамично).