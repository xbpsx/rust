Метод **`.expect()`** — это самый быстрый и прямолинейный способ в Rust обработать перечисление `Result`. Его можно назвать «методом оптимиста».

Вот как он работает на практике:

#### 1. Как он действует внутри

Когда вы вызываете `.expect("Сообщение")`, программа проверяет содержимое `Result`:

- **Если там `Ok` (Успех):** Метод «вскрывает» этот конверт, достает оттуда полезное значение (например, число считанных байт) и отдает его вам. Программа спокойно идет дальше.
- **Если там `Err` (Ошибка):** Программа немедленно завершает работу с аварийной остановкой (**panic**). В терминал выводится текст, который вы написали внутри кавычек, и техническая информация об ошибке.

#### 2. Зачем это нужно?

Вы можете спросить: _«Зачем мне специально ломать программу?»_.

В системном программировании есть ситуации, когда **нельзя продолжать**, если что-то пошло не так. Если мы не смогли прочитать данные из терминала (ошибка ОС), то нашей программе для угадывания чисел просто не с чем работать.

`.expect()` говорит Rust:

> _«Я верю, что здесь всё будет хорошо. Но если вдруг случится катастрофа — лучше сразу останови программу и покажи мне это сообщение, чем работать с неправильными данными»._

#### 3. Пример из жизни

Представьте, что вы заказываете посылку (это ваш `Result`):

- Вы вызываете метод **«Вскрыть и проверить»** (`.expect`).
- Если внутри **товар** (`Ok`), вы его забираете и пользуетесь.
- Если внутри **пусто или записка об ошибке** (`Err`), вы впадаете в панику, бросаете всё и кричите: _«Посылка не пришла!»_ (это ваше сообщение в `expect`).

#### 4. Почему это важно для новичка?

В реальных больших проектах программисты стараются обрабатывать ошибки более мягко (например, просят пользователя попробовать еще раз). Но на этапе обучения и написания прототипов `.expect()` — это лучший инструмент, потому что:

1. Он **короткий**.
2. Он **заставляет вас признать**, что ошибка возможна.
3. Он **документирует** ваши ожидания (в сообщении вы пишете, что именно должно было произойти).

---
#### Что будет, если его НЕ вызвать?

Если вы просто напишете `io::stdin().read_line(&mut guess);` без `.expect()`, компилятор Rust выдаст **предупреждение (warning)**:  
`unused` std::result::Result `that must be used`.

Rust как бы намекает: _"Ты получил отчет о безопасности, но даже не взглянул в него. А вдруг там ошибка?"_. Метод `.expect()` — это самый простой способ официально «взглянуть» на этот отчет.