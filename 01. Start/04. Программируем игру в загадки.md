Давайте окунёмся в Rust, вместе поработав над практическим проектом! В этой главе вы познакомитесь с несколькими общими концепциями Rust, показав, как использовать их в реальной программе. Вы узнаете о `let` , `match`, методах, ассоциированных функциях, внешних контейнерах и многом другом! В следующих главах мы рассмотрим эти идеи более подробно. В этой главе вы просто попрактикуетесь в основах.

Мы реализуем классическую для начинающих программистов задачу — игру в загадки. Вот как это работает: **программа генерирует случайное целое число в диапазоне от 1 до 100**. Затем она предлагает игроку его угадать. После ввода числа программа укажет, меньше или больше было загаданное число. Если догадка верна, игра напечатает поздравительное сообщение и завершится.

[[#Настройка нового проекта]]
[[#Обработка догадки]]
[[#Хранение значений с помощью переменных]]
[[#Получение пользовательского ввода]]
[[#Обработка потенциального сбоя с помощью типа `Result`]]
[[#Вывод значений с помощью заполнителей `println!`]]


---
### Настройка нового проекта

Для настройки нового проекта перейдите в каталог _projects_, который вы создали в главе 1, и создайте новый проект с использованием Cargo, как показано ниже:

```bash
cargo new guessing_game
cd guessing_game
```

Первая команда, `cargo new`, принимает в качестве первого аргумента имя проекта (`guessing_game`). Вторая команда изменяет каталог на новый каталог проекта.

Загляните в созданный файл _Cargo.toml_:

```toml
#Cargo.toml
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2024"

[dependencies]
```

Как вы уже видели в главе 1, `cargo new` создаёт программу «Hello, world!». Посмотрите файл _src/main.rs_:

```rust
fn main() {
    println!("Hello, world!");
}
```

Теперь давайте скомпилируем программу «Hello, world!» и сразу на этом же этапе запустим её с помощью команды `cargo run`:

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/guessing_game`
Hello, world!
```

Команда `run` пригодится, **когда необходимо ускоренно выполнить итерацию проекта**. Именно так мы собираемся делать в этом проекте, быстро тестируя каждую итерацию, прежде чем перейти к следующей.

Снова откройте файл _src/main.rs_. Весь код вы будете писать в нем.

---
## Обработка догадки

Первая часть программы запрашивает ввод данных пользователем, обрабатывает их и проверяет, что они в ожидаемой форме. Начнём с того, что позволим игроку ввести догадку. Вставьте код из листинга 2-1 в _src/main.rs_.

Файл: `src/main.rs`

```rust
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}
```
_Листинг 2-1: код, который получает догадку от пользователя и выводит её на экран_

Этот код содержит много информации, поэтому давайте **рассмотрим его построчно**. Чтобы получить пользовательский ввод и затем вывести результат, нам нужно включить в область видимости **библиотеку ввода/вывода** `io`. Библиотека `io` является частью стандартной библиотеки, известной как `std`:

```rust
use std::io;
```

[[use_std_io]]

По умолчанию в Rust есть набор элементов, **определённых в стандартной библиотеке**, которые он добавляет в область видимости каждой программы. Этот набор называется _прелюдией_, и вы можете изучить его содержание [в документации стандартной библиотеки](https://doc.rust-lang.ru/std/prelude/index.html).

Если тип, который требуется использовать, отсутствует в прелюдии, его нужно явно ввести в область видимости с помощью оператора `use`. Использование библиотеки `std::io` предоставляет ряд полезных функциональных возможностей, включая способность **принимать пользовательский ввод.**

Как уже отмечалось в главе 1, функция `main` является **точкой входа в программу**:

```rust
fn main() {
```

Ключевое слово `fn` объявляет новую функцию, круглые скобки `()` показывают, что у функции нет входных параметров, фигурная скобка `{` - обозначение начала тела функции.

Также в главе 1 упоминалось, что `println!` — это макрос, **который выводит строку на экран:**

```rust
println!("Guess the number!");

println!("Please input your guess.");
```

Этот код показывает информацию о ходе игры и запрашивает пользовательский ввод.

---
### Хранение значений с помощью переменных

Далее мы создаём _переменную_ для хранения пользовательского ввода, как показано ниже:

```rust
let mut guess = String::new();
```

Вот теперь программа становится интереснее! В этой маленькой строке на самом деле происходит очень многое. Для создания переменной мы используем оператор `let`. Вот ещё один пример:

```rust
let apples = 5;
```

Эта строка создаёт новую переменную с именем `apples` и привязывает её к значению 5. **В Rust переменные неизменяемы по умолчанию**, то есть как только мы присвоим переменной значение, оно не изменится. Мы подробно обсудим эту концепцию в разделе ["Переменные и изменчивость".](https://doc.rust-lang.ru/book/ch03-01-variables-and-mutability.html#variables-and-mutability) в главе 3. **Чтобы сделать переменную изменяемой**, мы добавляем `mut` перед её именем:

```rust
let apples = 5; // неизменяемая
let mut bananas = 5; // изменяемая
```

> Примечание: сочетание знаков `//` **начинает комментарий**, который продолжается до конца строки. Rust игнорирует всё, что находится в комментариях. 

Возвращаясь к программе игры "Угадайка" — теперь вы знаете, что `let mut guess` предоставит изменяемую переменную с именем `guess`. Знак равенства (`=`) сообщает Rust, **что сейчас нужно связать что-то с этой переменной**. Справа от знака равенства находится значение, связанное с `guess`, которое является **результатом вызова функции** `String::new`, возвращающей новый экземпляр `String`. [`String`](https://doc.rust-lang.ru/std/string/struct.String.html) — это тип строки, предоставляемый стандартной библиотекой, который является расширяемым фрагментом текста в кодировке UTF-8.

Синтаксис `::` в строке `::new` указывает, что `new` является ассоциированной функцией типа `String`. 

> _Ассоциированная функция_ — это функция, реализованная для типа, в данном случае `String`. 

Функция `new` создаёт новую пустую строку. Функцию `new` можно встретить во многих типах, это **типичное название для функции**, которая создаёт новое значение какого-либо типа.

В конечном итоге строка `let mut guess = String::new();` создала изменяемую переменную, которая связывается с новым пустым экземпляром `String`. Фух!

[[ассоциированная функция]]

---
### Получение пользовательского ввода

Напомним: **мы подключили функциональность ввода/вывода** из стандартной библиотеки с помощью `use std::io;` в первой строке программы. Теперь мы вызовем функцию `stdin` из модуля `io`, которая позволит нам обрабатывать пользовательский ввод:

```rust
    io::stdin()
        .read_line(&mut guess)
```

Если бы мы не импортировали библиотеку `io` с помощью `use std::io` в начале программы, мы все равно могли бы использовать эту функцию, записав её вызов как `std::io::stdin`. 

Функция `stdin` возвращает экземпляр [`std::io::Stdin`](https://doc.rust-lang.ru/std/io/struct.Stdin.html), который является типом, представляющим **дескриптор стандартного ввода для вашего терминала**.

Далее строка `.read_line(&mut guess)` вызывает [[метод read_line ]]на дескрипторе стандартного ввода для получения ввода от пользователя. Мы также передаём `&mut guess` в качестве аргумента `read_line`, сообщая ему, в какой строке хранить пользовательский ввод. 

> Главная задача `read_line` — принять все, что пользователь вводит в стандартный ввод, и сложить это в строку (не переписывая её содержимое), поэтому мы передаём эту строку в качестве аргумента.

Строковый аргумент должен быть изменяемым, чтобы метод мог изменить содержимое строки.

Символ `&` указывает, что этот аргумент является [[ссылкой]], которая предоставляет возможность нескольким частям вашего кода получить доступ к одному фрагменту данных без необходимости копировать эти данные в память несколько раз. **Ссылки — это сложная функциональная возможность**, а одним из главных преимуществ Rust является безопасность и простота использования ссылок. Чтобы дописать эту программу, вам не понадобится знать много таких подробностей. Пока вам достаточно знать, что ссылки, как и переменные, по умолчанию неизменяемы. Соответственно, чтобы сделать её изменяемой, нужно написать `&mut guess`, а не `&guess`. (В главе 4 ссылки будут описаны более подробно).

[[Память в rust]]

---
### Обработка потенциального сбоя с помощью типа `Result`

Мы всё ещё работаем над этой строкой кода. Сейчас мы обсуждаем третью строку, но обратите внимание, что она по-прежнему является частью одной логической строки. Следующая часть — метод:

```rust
.expect("Failed to read line");
```

Мы могли бы написать этот код так:

```rust
io::stdin().read_line(&mut guess).expect("Failed to read line");
```

Однако одну длинную строку трудно читать, поэтому лучше разделить её. При вызове метода с помощью синтаксиса `.method_name()` часто целесообразно вводить новую строку и другие пробельные символы, чтобы разбить длинные строки. Теперь давайте обсудим, что делает эта строка.

Как упоминалось ранее, `read_line` помещает всё, что вводит пользователь, в строку, которую мы ему передаём, **но также возвращает значение** `Result`. 

> [`Result`](https://doc.rust-lang.ru/std/result/enum.Result.html) — это [_перечисление_](https://doc.rust-lang.ru/book/ch06-00-enums.html), часто называемое [[enum]], то есть тип, который может находиться в одном из нескольких возможных состояний.

Мы называем каждое такое состояние _вариантом_.

В [Главе 6](https://doc.rust-lang.ru/book/ch06-00-enums.html) рассмотрим перечисления более подробно. Задачей типов `Result` является кодирование информации для обработки ошибок.

Вариантами `Result` являются `Ok` и `Err`. 

- Вариант `Ok` указывает, что операция завершилась успешно, а внутри `Ok` находится успешно сгенерированное значение. 
- Вариант `Err` означает, что операция не удалась, а `Err` содержит информацию о причинах неудачи.

Значения типа `Result`, как и значения любого типа, имеют определённые для них методы. У экземпляра `Result` есть [[метод expect]], который можно вызвать. Если этот экземпляр `Result` является значением `Err`, `expect` вызовет сбой программы и отобразит сообщение, которое вы передали в качестве аргумента. Если метод `read_line` возвращает `Err`, то это, скорее всего, результат ошибки базовой операционной системы. Если экземпляр `Result` является значением `Ok`, `expect` возьмёт возвращаемое значение, которое удерживает `Ok`, и вернёт вам только это значение, чтобы вы могли его использовать далее. В данном случае это значение представляет собой количество байтов, введённых пользователем.

Если не вызвать `expect`, программа скомпилируется, но будет получено предупреждение:

```bash
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --> src/main.rs:10:5
   |
10 |     io::stdin().read_line(&mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&mut guess);
   |     +++++++

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s
```

Rust предупреждает о неиспользованном значении `Result`, возвращаемого из `read_line`, показывая, что программа не учла возможность возникновения ошибки.

Правильный способ убрать предупреждение — это написать обработку ошибок, но в нашем случае мы просто хотим аварийно завершить программу при возникновении проблемы, поэтому используем `expect`. О способах восстановления после ошибок вы узнаете в [главе 9](https://doc.rust-lang.ru/book/ch09-02-recoverable-errors-with-result.html).

---
### Вывод значений с помощью заполнителей `println!`

Кроме закрывающей фигурной скобки, в коде на данный момент есть ещё только одно место для обсуждения:

```rust
println!("You guessed: {guess}");
```

Этот код выводит строку, которая теперь содержит ввод пользователя. Набор фигурных скобок `{}` является заполнителем: думайте о `{}` как о маленьких клешнях краба, которые удерживают значение на месте. При печати значения переменной имя переменной может заключаться в фигурные скобки. При печати результата вычисления выражения поместите пустые фигурные скобки в строку формата, затем после строки формата укажите список выражений, разделённых запятыми, которые будут напечатаны в каждом заполнителе пустой фигурной скобки в том же порядке. Печать переменной и результата выражения одним вызовом `println!` будет выглядеть так:

```rust
#![allow(unused)]
fn main() {
let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2);
}
```

Этот код выведет [[x = 5 and y + 2 = 12]].

[[макрос println!]]

---
