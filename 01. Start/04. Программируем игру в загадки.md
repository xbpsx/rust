Давайте окунёмся в Rust, вместе поработав над практическим проектом! В этой главе вы познакомитесь с несколькими общими концепциями Rust, показав, как использовать их в реальной программе. Вы узнаете о `let` , `match`, методах, ассоциированных функциях, внешних контейнерах и многом другом! В следующих главах мы рассмотрим эти идеи более подробно. В этой главе вы просто попрактикуетесь в основах.

Мы реализуем классическую для начинающих программистов задачу — игру в загадки. Вот как это работает: **программа генерирует случайное целое число в диапазоне от 1 до 100**. Затем она предлагает игроку его угадать. После ввода числа программа укажет, меньше или больше было загаданное число. Если догадка верна, игра напечатает поздравительное сообщение и завершится.

[[#Настройка нового проекта]]
[[#Обработка догадки]]
[[#Хранение значений с помощью переменных]]
[[#Получение пользовательского ввода]]
[[#Обработка потенциального сбоя с помощью типа `Result`]]
[[#Вывод значений с помощью заполнителей `println!`]]
[[#Тестирование первой части]]
[[#Генерация секретного числа]]
[[#Использование крейта для получения дополнительного функционала]]
[[#Обеспечение воспроизводимых сборок с помощью файла _Cargo.lock_]]
[[#Обновление пакета для получения новой версии]]


---
### Настройка нового проекта

Для настройки нового проекта перейдите в каталог _projects_, который вы создали в главе 1, и создайте новый проект с использованием Cargo, как показано ниже:

```bash
cargo new guessing_game
cd guessing_game
```

Первая команда, `cargo new`, принимает в качестве первого аргумента имя проекта (`guessing_game`). Вторая команда изменяет каталог на новый каталог проекта.

Загляните в созданный файл _Cargo.toml_:

```toml
#Cargo.toml
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2024"

[dependencies]
```

Как вы уже видели в главе 1, `cargo new` создаёт программу «Hello, world!». Посмотрите файл _src/main.rs_:

```rust
fn main() {
    println!("Hello, world!");
}
```

Теперь давайте скомпилируем программу «Hello, world!» и сразу на этом же этапе запустим её с помощью команды `cargo run`:

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.08s
     Running `target/debug/guessing_game`
Hello, world!
```

Команда `run` пригодится, **когда необходимо ускоренно выполнить итерацию проекта**. Именно так мы собираемся делать в этом проекте, быстро тестируя каждую итерацию, прежде чем перейти к следующей.

Снова откройте файл _src/main.rs_. Весь код вы будете писать в нем.

---
## Обработка догадки

Первая часть программы запрашивает ввод данных пользователем, обрабатывает их и проверяет, что они в ожидаемой форме. Начнём с того, что позволим игроку ввести догадку. Вставьте код из листинга 2-1 в _src/main.rs_.

Файл: `src/main.rs`

```rust
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}
```
_Листинг 2-1: код, который получает догадку от пользователя и выводит её на экран_

Этот код содержит много информации, поэтому давайте **рассмотрим его построчно**. Чтобы получить пользовательский ввод и затем вывести результат, нам нужно включить в область видимости **библиотеку ввода/вывода** `io`. Библиотека `io` является частью стандартной библиотеки, известной как `std`:

```rust
use std::io;
```

[[use_std_io]]

По умолчанию в Rust есть набор элементов, **определённых в стандартной библиотеке**, которые он добавляет в область видимости каждой программы. Этот набор называется _прелюдией_, и вы можете изучить его содержание [в документации стандартной библиотеки](https://doc.rust-lang.ru/std/prelude/index.html).

Если тип, который требуется использовать, отсутствует в прелюдии, его нужно явно ввести в область видимости с помощью оператора `use`. Использование библиотеки `std::io` предоставляет ряд полезных функциональных возможностей, включая способность **принимать пользовательский ввод.**

Как уже отмечалось в главе 1, функция `main` является **точкой входа в программу**:

```rust
fn main() {
```

Ключевое слово `fn` объявляет новую функцию, круглые скобки `()` показывают, что у функции нет входных параметров, фигурная скобка `{` - обозначение начала тела функции.

Также в главе 1 упоминалось, что `println!` — это макрос, **который выводит строку на экран:**

```rust
println!("Guess the number!");

println!("Please input your guess.");
```

Этот код показывает информацию о ходе игры и запрашивает пользовательский ввод.

---
### Хранение значений с помощью переменных

Далее мы создаём _переменную_ для хранения пользовательского ввода, как показано ниже:

```rust
let mut guess = String::new();
```

Вот теперь программа становится интереснее! В этой маленькой строке на самом деле происходит очень многое. Для создания переменной мы используем оператор `let`. Вот ещё один пример:

```rust
let apples = 5;
```

Эта строка создаёт новую переменную с именем `apples` и привязывает её к значению 5. **В Rust переменные неизменяемы по умолчанию**, то есть как только мы присвоим переменной значение, оно не изменится. Мы подробно обсудим эту концепцию в разделе ["Переменные и изменчивость".](https://doc.rust-lang.ru/book/ch03-01-variables-and-mutability.html#variables-and-mutability) в главе 3. **Чтобы сделать переменную изменяемой**, мы добавляем `mut` перед её именем:

```rust
let apples = 5; // неизменяемая
let mut bananas = 5; // изменяемая
```

> Примечание: сочетание знаков `//` **начинает комментарий**, который продолжается до конца строки. Rust игнорирует всё, что находится в комментариях. 

Возвращаясь к программе игры "Угадайка" — теперь вы знаете, что `let mut guess` предоставит изменяемую переменную с именем `guess`. Знак равенства (`=`) сообщает Rust, **что сейчас нужно связать что-то с этой переменной**. Справа от знака равенства находится значение, связанное с `guess`, которое является **результатом вызова функции** `String::new`, возвращающей новый экземпляр `String`. [`String`](https://doc.rust-lang.ru/std/string/struct.String.html) — это тип строки, предоставляемый стандартной библиотекой, который является расширяемым фрагментом текста в кодировке UTF-8.

Синтаксис `::` в строке `::new` указывает, что `new` является ассоциированной функцией типа `String`. 

> _Ассоциированная функция_ — это функция, реализованная для типа, в данном случае `String`. 

Функция `new` создаёт новую пустую строку. Функцию `new` можно встретить во многих типах, это **типичное название для функции**, которая создаёт новое значение какого-либо типа.

В конечном итоге строка `let mut guess = String::new();` создала изменяемую переменную, которая связывается с новым пустым экземпляром `String`. Фух!

[[ассоциированная функция]]

---
### Получение пользовательского ввода

Напомним: **мы подключили функциональность ввода/вывода** из стандартной библиотеки с помощью `use std::io;` в первой строке программы. Теперь мы вызовем функцию `stdin` из модуля `io`, которая позволит нам обрабатывать пользовательский ввод:

```rust
    io::stdin()
        .read_line(&mut guess)
```

Если бы мы не импортировали библиотеку `io` с помощью `use std::io` в начале программы, мы все равно могли бы использовать эту функцию, записав её вызов как `std::io::stdin`. 

Функция `stdin` возвращает экземпляр [`std::io::Stdin`](https://doc.rust-lang.ru/std/io/struct.Stdin.html), который является типом, представляющим **дескриптор стандартного ввода для вашего терминала**.

Далее строка `.read_line(&mut guess)` вызывает [[метод read_line ]]на дескрипторе стандартного ввода для получения ввода от пользователя. Мы также передаём `&mut guess` в качестве аргумента `read_line`, сообщая ему, в какой строке хранить пользовательский ввод. 

> Главная задача `read_line` — принять все, что пользователь вводит в стандартный ввод, и сложить это в строку (не переписывая её содержимое), поэтому мы передаём эту строку в качестве аргумента.

Строковый аргумент должен быть изменяемым, чтобы метод мог изменить содержимое строки.

Символ `&` указывает, что этот аргумент является [[ссылкой]], которая предоставляет возможность нескольким частям вашего кода получить доступ к одному фрагменту данных без необходимости копировать эти данные в память несколько раз. **Ссылки — это сложная функциональная возможность**, а одним из главных преимуществ Rust является безопасность и простота использования ссылок. Чтобы дописать эту программу, вам не понадобится знать много таких подробностей. Пока вам достаточно знать, что ссылки, как и переменные, по умолчанию неизменяемы. Соответственно, чтобы сделать её изменяемой, нужно написать `&mut guess`, а не `&guess`. (В главе 4 ссылки будут описаны более подробно).

[[Память в rust]]

---
### Обработка потенциального сбоя с помощью типа `Result`

Мы всё ещё работаем над этой строкой кода. Сейчас мы обсуждаем третью строку, но обратите внимание, что она по-прежнему является частью одной логической строки. Следующая часть — метод:

```rust
.expect("Failed to read line");
```

Мы могли бы написать этот код так:

```rust
io::stdin().read_line(&mut guess).expect("Failed to read line");
```

Однако одну длинную строку трудно читать, поэтому лучше разделить её. При вызове метода с помощью синтаксиса `.method_name()` часто целесообразно вводить новую строку и другие пробельные символы, чтобы разбить длинные строки. Теперь давайте обсудим, что делает эта строка.

Как упоминалось ранее, `read_line` помещает всё, что вводит пользователь, в строку, которую мы ему передаём, **но также возвращает значение** `Result`. 

> [`Result`](https://doc.rust-lang.ru/std/result/enum.Result.html) — это [_перечисление_](https://doc.rust-lang.ru/book/ch06-00-enums.html), часто называемое [[enum]], то есть тип, который может находиться в одном из нескольких возможных состояний.

Мы называем каждое такое состояние _вариантом_.

В [Главе 6](https://doc.rust-lang.ru/book/ch06-00-enums.html) рассмотрим перечисления более подробно. Задачей типов `Result` является кодирование информации для обработки ошибок.

Вариантами `Result` являются `Ok` и `Err`. 

- Вариант `Ok` указывает, что операция завершилась успешно, а внутри `Ok` находится успешно сгенерированное значение. 
- Вариант `Err` означает, что операция не удалась, а `Err` содержит информацию о причинах неудачи.

Значения типа `Result`, как и значения любого типа, имеют определённые для них методы. У экземпляра `Result` есть [[метод expect]], который можно вызвать. Если этот экземпляр `Result` является значением `Err`, `expect` вызовет сбой программы и отобразит сообщение, которое вы передали в качестве аргумента. Если метод `read_line` возвращает `Err`, то это, скорее всего, результат ошибки базовой операционной системы. Если экземпляр `Result` является значением `Ok`, `expect` возьмёт возвращаемое значение, которое удерживает `Ok`, и вернёт вам только это значение, чтобы вы могли его использовать далее. В данном случае это значение представляет собой количество байтов, введённых пользователем.

Если не вызвать `expect`, программа скомпилируется, но будет получено предупреждение:

```bash
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --> src/main.rs:10:5
   |
10 |     io::stdin().read_line(&mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
   |
10 |     let _ = io::stdin().read_line(&mut guess);
   |     +++++++

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s
```

Rust предупреждает о неиспользованном значении `Result`, возвращаемого из `read_line`, показывая, что программа не учла возможность возникновения ошибки.

Правильный способ убрать предупреждение — это написать обработку ошибок, но в нашем случае мы просто хотим аварийно завершить программу при возникновении проблемы, поэтому используем `expect`. О способах восстановления после ошибок вы узнаете в [главе 9](https://doc.rust-lang.ru/book/ch09-02-recoverable-errors-with-result.html).

---
### Вывод значений с помощью заполнителей `println!`

Кроме закрывающей фигурной скобки, в коде на данный момент есть ещё только одно место для обсуждения:

```rust
println!("You guessed: {guess}");
```

Этот код выводит строку, которая теперь содержит ввод пользователя. Набор фигурных скобок `{}` является заполнителем: думайте о `{}` как о маленьких клешнях краба, которые удерживают значение на месте. При печати значения переменной имя переменной может заключаться в фигурные скобки. При печати результата вычисления выражения поместите пустые фигурные скобки в строку формата, затем после строки формата укажите список выражений, разделённых запятыми, которые будут напечатаны в каждом заполнителе пустой фигурной скобки в том же порядке. Печать переменной и результата выражения одним вызовом `println!` будет выглядеть так:

```rust
#![allow(unused)]
fn main() {
let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2);
}
```

Этот код выведет [[x = 5 and y + 2 = 12]].

[[макрос println!]]

---
### Тестирование первой части

Давайте протестируем первую часть игры. Запустите её используя `cargo run`:

```bash
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
```

На данном этапе первая часть игры завершена: мы получаем ввод с клавиатуры и затем печатаем его.

---
## Генерация секретного числа

Далее **нам нужно сгенерировать секретное число**, которое пользователь попытается угадать. Секретное число должно быть каждый раз разным, чтобы в игру можно было играть несколько раз. Мы будем использовать случайное число в диапазоне от 1 до 100, чтобы игра не была слишком сложной. Rust пока не включает функциональность случайных чисел в свою стандартную библиотеку. Однако команда Rust предоставляет [крейт `rand`] с подобной функциональностью.

---
### Использование крейта для получения дополнительного функционала

Помните, что пакет (crate) - это коллекция файлов исходного кода Rust. Проект, создаваемый нами, представляет собой  _бинарный пакет (binary crate)_, который является исполняемым файлом. Пакет `rand` - это _библиотечный пакет (library crate)_, содержащий код, который предназначен для использования в других программах и поэтому не может исполняться сам по себе.

Координация работы внешних пакетов является тем местом, где Cargo на самом деле блистает. Чтобы начать писать код, использующий `rand`, необходимо изменить файл _Cargo.toml_, включив в него в качестве зависимости пакет `rand`. Итак, откройте этот файл и добавьте следующую строку внизу под заголовком секции `[dependencies]`, созданным для вас Cargo. Обязательно укажите `rand` в точности так же, как здесь, с таким же номером версии, иначе примеры кода из этого урока могут не заработать.

```toml
[dependencies]
rand = "0.8.5"
```

В файле _Cargo.toml_ всё, что следует за заголовком, является частью этой секции, которая продолжается до тех пор, пока не начнётся следующая. В `[dependencies]` вы сообщаете Cargo, от каких внешних крейтов зависит ваш проект и какие версии этих крейтов вам нужны. В этом случае мы указываем крейт `rand` со спецификатором семантической версии `0.8.5`. Cargo понимает [семантическое версионирование](http://semver.org) (иногда называемое _SemVer_), которое является стандартом для описания версий. Число `0.8.5` на самом деле является сокращением от `^0.8.5`, что означает любую версию не ниже `0.8.5`, но ниже `0.9.0`.

Cargo рассчитывает, что эти версии имеют общедоступное API, совместимое с версией `0.8.5`, и вы получите последние версии исправлений, которые по-прежнему будут компилироваться с кодом из этой главы. Не гарантируется, что версия `0.9.0` или выше будет иметь тот же API, что и в следующих примерах.

Теперь, не меняя ничего в коде, давайте соберём проект, как показано в листинге 2-2.

```bash
$ cargo build
Updating crates.io index
  Downloaded rand v0.8.5
  Downloaded libc v0.2.127
  Downloaded getrandom v0.2.7
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.16
  Downloaded rand_chacha v0.3.1
  Downloaded rand_core v0.6.3
   Compiling libc v0.2.127
   Compiling getrandom v0.2.7
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.16
   Compiling rand_core v0.6.3
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
Finished dev [unoptimized + debuginfo] target(s) in 2.53s
```
_Листинг 2-2: результат выполнения cargo build после добавления крейта rand в качестве зависимости_

Вы можете увидеть другие номера версий (но все они будут совместимы с кодом благодаря SemVer), другие строки (в зависимости от операционной системы), а также строки могут быть расположены в другом порядке.

Когда мы включаем внешнюю зависимость, Cargo берет последние версии всего, что нужно этой зависимости, из _реестра (registry)_, который является копией данных с [Crates.io](https://crates.io/). 

> **Crates.io** — это место, где участники экосистемы Rust размещают свои проекты с открытым исходным кодом для использования другими.

После обновления реестра Cargo проверяет раздел `[dependencies]` и загружает все указанные в списке пакеты, которые ещё не были загружены. В нашем случае, хотя мы указали только `rand` в качестве зависимости, Cargo также захватил другие пакеты, от которых зависит работа `rand`. После загрузки пакетов Rust компилирует их, а затем компилирует проект с имеющимися зависимостями.

Если сразу же запустить `cargo build` снова, не внося никаких изменений, то кроме строки `Finished` вы не получите никакого вывода. Cargo знает, что он уже загрузил и скомпилировал зависимости, и вы не вносили никаких изменений в файл _Cargo.toml_. Cargo также знает, что вы ничего не изменили в своём коде, поэтому он не перекомпилирует и его. Если делать нечего, он просто завершает работу.

Если вы откроете файл _src/main.rs_, внесёте тривиальное изменение, а затем сохраните его и снова соберёте, вы увидите только две строки вывода:

```bash
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
   Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
```

Эти строки показывают, что Cargo обновляет сборку только с вашим крошечным изменением в файле _src/main.rs_. Ваши зависимости не изменились, поэтому Cargo знает, что может повторно использовать то, что уже скачано и скомпилировано для них.

---
#### Обеспечение воспроизводимых сборок с помощью файла _Cargo.lock_

В Cargo есть механизм, обеспечивающий возможность пересобрать всё тот же артефакт каждый раз, когда вы или кто-либо другой собирает ваш код. Пока вы не укажете обратное, Cargo будет использовать только те версии зависимостей, которые были заданы ранее. Например, допустим, что на следующей неделе выходит версия 0.8.6 пакета `rand` , и она содержит важное исправление ошибки, но также регрессию, которая может сломать ваш код. Чтобы справиться с этим, Rust создаёт файл _Cargo.lock_ при первом запуске `cargo build`, поэтому теперь он есть в каталоге _guessing_game_.

Когда вы создаёте проект в первый раз, Cargo определяет все версии зависимостей, которые соответствуют критериям, а затем записывает их в файл _Cargo.lock_. Когда вы будете собирать свой проект в будущем, Cargo увидит, что файл _Cargo.lock_ существует, и будет использовать указанные там версии, а не выполнять всю работу по выяснению версий заново. Это позволяет автоматически создавать воспроизводимую сборку. Другими словами, ваш проект останется на `0.8.5` до тех пор, пока вы явно не обновите его благодаря файлу _Cargo.lock_. Поскольку файл _Cargo.lock_ важен для воспроизводимых сборок, он часто хранится в системе управления версиями вместе с остальным кодом проекта.

---
#### Обновление пакета для получения новой версии

Если вы _захотите_ обновить пакет, Cargo предоставляет команду `update`, которая игнорирует файл _Cargo.lock_ и определяет последние версии, соответствующие вашим спецификациям из файла _Cargo.toml_. После этого Cargo запишет эти версии в файл _Cargo.lock_. Иначе по умолчанию Cargo будет искать только версии больше 0.8.5, но при этом меньше 0.9.0. Если пакет `rand` имеет две новые версии — 0.8.6 и 0.9.0 — то при запуске `cargo update` вы увидите следующее:

```bash
$ cargo update
    Updating crates.io index
    Updating rand v0.8.5 -> v0.8.6
```

Cargo игнорирует релиз 0.9.0. В этот момент также появится изменение в файле _Cargo.lock_, указывающее на то, что версия `rand`, которая теперь используется, равна 0.8.6. Чтобы использовать `rand` версии 0.9.0 или любой другой версии из серии 0.9._x_, необходимо обновить файл _Cargo.toml_ следующим образом:

```toml
[dependencies]
rand = "0.9.0"
```

В следующий раз, при запуске `cargo build`, Cargo обновит реестр доступных пакетов и пересмотрит ваши требования к `rand` в соответствии с новой версией, которую вы указали.

Можно много рассказать про [Cargo](https://doc.rust-lang.org/cargo/) и [его экосистему](https://doc.rust-lang.org/cargo/reference/publishing.html) которые мы обсудим в главе 14, сейчас это все что вам нужно знать. Cargo позволяет очень легко повторно использовать библиотеки, поэтому Rust разработчики имеют возможность писать меньшие проекты, которые скомпонованы из многих пакетов.

---
